
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-11-14"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1></h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Pr&aacute;ctica 5 - Prefijo c&iacute;clico</a></li><li><a href="#2">Ejercicio 2.1 - Convolucion circular</a></li><li><a href="#3">2.1.1 Representaci&oacute;n del espectro de x en dB</a></li><li><a href="#5">2.1.2 Representaci&oacute;n de H en dB</a></li><li><a href="#7">2.1.3 C&aacute;lculo de la convoluci&oacute;n lineal y representaci&oacute;n del espectro de Y en dB</a></li><li><a href="#9">2.1.4 C&aacute;lculo de la convoluci&oacute;n circular y representaci&oacute;n del espectro de Yc en dB</a></li><li><a href="#11">2.1.5 Comparaci&oacute;n de Y te&oacute;rica, Y e Yc</a></li><li><a href="#14">2.1.6 Generaci&oacute;n del prefijo c&iacute;clico</a></li><li><a href="#16">2.1.7 Obtenci&oacute;n de Yc mediante convoluci&oacute;n lineal</a></li><li><a href="#20">Ejercicio 2.2 - Ecualizacion</a></li><li><a href="#21">2.2.1 Generaci&oacute;n de una se&ntilde;al ofdm</a></li><li><a href="#23">2.2.2 Recepci&oacute;n de la se&ntilde;al transmitida tras pasar por el canal</a></li><li><a href="#24">2.2.3 Eliminaci&oacute;n del periodo de guarda</a></li><li><a href="#25">2.2.4 Ecualizaci&oacute;n</a></li><li><a href="#27">2.2.5 Comparaci&oacute;n de s&iacute;mbolos QPSK</a></li><li><a href="#29">2.2.6  Repetici&oacute;n con l_cp = 4</a></li><li><a href="#32">2.2.7 Repetici&oacute;n con l_cp = 16</a></li></ul></div><h2 id="1">Pr&aacute;ctica 5 - Prefijo c&iacute;clico</h2><p>Teresa Gonz&aacute;lez Garc&iacute;a y Mar&iacute;a Jos&eacute; Medina Hern&aacute;ndez</p><h2 id="2">Ejercicio 2.1 - Convolucion circular</h2><h2 id="3">2.1.1 Representaci&oacute;n del espectro de x en dB</h2><pre class="codeinput"><span class="comment">% N puntos FFT</span>
N=256;
<span class="comment">% frecuencia de muestreo</span>
Fs=25600;
<span class="comment">% periodo de muestreo</span>
Ts=1/Fs;

<span class="comment">% se&ntilde;al de entrada aleatoria</span>
x=randi([-1,1],1,N);

<span class="comment">% X(f) -&gt; FFT. Es necesario escalar las amplitudes /N para que la operaci&oacute;n fft de</span>
<span class="comment">% matlab coincida con la f&oacute;rmula te&oacute;rica.</span>
X=fft(x,N)/N;

<span class="comment">% vector f (paso Fs) -&gt; mitad puntos NFFT espectro + y mitad -</span>
f=-N*Fs/2:Fs:N*Fs/2-Fs;

<span class="comment">%Se representa el espectro del canal en dbs con fftshift, para visualizar el resultado de la FFT con el componente de f=0 en el centro del espectro.</span>
figure
plot (f/1000,20*log(abs(fftshift(X))));
title(<span class="string">'Representacion abs(X(f)) en db'</span>);
xlabel(<span class="string">'F(Khz)'</span>);
ylabel(<span class="string">'Amplitud(db)'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_01.png" alt=""> <p>Se representa el espectro de una se&ntilde;al aleatoria (valores -1, 0,1) de N puntos. Como se puede observar, el espectro es sim&eacute;trico, ya que las amplitudes (en valor absoluto) de las frecuencias de rango -N/2*Fs a 0 coiciden con las de las frecuencias de rango 0 a +N/2*Fs.</p><h2 id="5">2.1.2 Representaci&oacute;n de H en dB</h2><pre class="codeinput"><span class="comment">% h[n] es un filtro digital de k=9 posiciones en total (en el dominio del tiempo</span>
<span class="comment">% discreto).</span>
h=[-0.1,0.3,-0.5,0.7,-0.9,0.7, -0.5, 0.3, -0.1];

<span class="comment">% H(f) es la respuesta al impulso del canal -&gt; FFT.</span>
H=fft(h,N)/N;
<span class="comment">% Representacion |H(f)| el dominio de la frecuencia (db)</span>
figure
plot (f/1000,20*log(abs(fftshift(H))));
title(<span class="string">'Representacion |H(f)| en db'</span>);
xlabel(<span class="string">'F(Khz)'</span>);
ylabel(<span class="string">'|Amplitud(db)|'</span>);
grid <span class="string">on</span>

<span class="comment">%Representacion |H(f)| en el dominio de la frecuencia (unidades naturales)</span>
figure
plot(f/1000,abs(fftshift(H)));
title(<span class="string">'Representacion |H(f)|'</span>);
xlabel(<span class="string">'F(Khz)'</span>);
ylabel(<span class="string">'Amplitud'</span>);
grid <span class="string">on</span>

<span class="comment">%Representacion |H(f)| en el dominio de la frecuencia (unidades naturales)</span>
figure
plot(f/1000,abs(fftshift(H)));
title(<span class="string">'Representacion |H(f)|'</span>);
xlabel(<span class="string">'F(Khz)'</span>);
ylabel(<span class="string">'Amplitud'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_02.png" alt=""> <img vspace="5" hspace="5" src="main_03.png" alt=""> <img vspace="5" hspace="5" src="main_04.png" alt=""> <p>Como se puede observar, el espectro de nuevo es sim&eacute;trico, y corresponde a un filtro que aten&uacute;a la se&ntilde;al de entrada principalmente en el rango de frecuencias de -2000Khz a 2000Khz. Deja pasar los tonos en f=-3000Khz y 3000Khz.</p><h2 id="7">2.1.3 C&aacute;lculo de la convoluci&oacute;n lineal y representaci&oacute;n del espectro de Y en dB</h2><p>y es la se&ntilde;al en recibida, es decir, x convolucionada con la respuesta al impulso del canal (h). El canal provocar&aacute; un retardo y un escalado de amplitud (atenuaci&oacute;n) de la se&ntilde;al de entrada x -&gt; y=suma(ak*x[n-k]). convolucion lineal</p><pre class="codeinput">y=conv(x,h);
<span class="comment">% y(f) = NFFT.</span>
Y=fft(y,N)/N;
figure;
plot (f/1000,20*log(abs(fftshift(Y))));
title(<span class="string">'Representacion Y(f) en db'</span>);
xlabel(<span class="string">'F(Khz)'</span>);
ylabel(<span class="string">'Amplitud(db)'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_05.png" alt=""> <pre>En la gr&aacute;fica se puede observar como las amplitudes de Y(f) resultante
se encuentran muy atenuadas en comparaci&oacute;n con las amplitudes de X(f)
(f=0, X(0)=-93db, Y(0)=-143 db,  debido al efecto del canal). Tambi&eacute;n se
observa como las amplitudes en f=+-3000Khz son las menos atenuadas
(-20db aprox). Se tiene en cuenta que la y[n] se encuentra retardada en
el tiempo, por lo que est&aacute; adelantada en frecuencia.</pre><h2 id="9">2.1.4 C&aacute;lculo de la convoluci&oacute;n circular y representaci&oacute;n del espectro de Yc en dB</h2><p>Para calcular la convolucion circular de x*h, se ha utilizado la funci&oacute;n cconv de MATLAB m&oacute;dulo N. Por defecto la funci&oacute;n cconv devuleve un vector de longitud LENGTH(A)+LENGTH(B)-1, lo cual es equivalente a la convoluci&oacute;n lineal. Sin embargo, nosotros necesitamos que sea de longitud N porque quremos que tenga la misma longitud que x = 256.</p><pre class="codeinput">yc=cconv(x,h,N);
Yc=fft(yc,N)/N;
figure;
plot (f/1000,20*log(abs(fftshift(Yc))));
title(<span class="string">'Representacion Yc(f) en db'</span>);
xlabel(<span class="string">'F(Khz)'</span>);
ylabel(<span class="string">'Amplitud(db)'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_06.png" alt=""> <p>Se observan las mismas conclusiones en cuanto a atenuaci&oacute;n que en el apartado anterior, pero el espectro es distinto en el rango de frecuencias +-2000Khz, porque las amplitudes resultantes de la convoluci&oacute;n circular son distintos a los de la convoluci&oacute;n lineal.</p><h2 id="11">2.1.5 Comparaci&oacute;n de Y te&oacute;rica, Y e Yc</h2><p>A continuaci&oacute;n se comparan la Y te&oacute;rica (X.*H*N) con la Y obtenida por</p><pre class="codeinput"><span class="comment">%convoluci&oacute;n circular y la obtenida por convoluci&oacute;n lineal.</span>
<span class="comment">% Se escala X*H (*N), ya que X*H resulta en amplitudes /N^2. As&iacute;, se puede</span>
<span class="comment">% comparar con las Y's (escaladas /N).</span>
Yteorica= (X.*H*N);
dif_circular=sum(abs(Yc - Yteorica));
disp([<span class="string">'Diferencia X*H con convolucion circular: '</span> num2str(dif_circular)]);
dif_lineal=sum(abs(Y-Yteorica));
disp([<span class="string">'Diferencia X*H con convolucion lineal: '</span> num2str(dif_lineal)]);
disp([<span class="string">'Diferencia entre convolucion circular y lineal: '</span> num2str(abs(dif_circular-dif_lineal))]);
</pre><pre class="codeoutput">Diferencia X*H con convolucion circular: 4.6228e-15
Diferencia X*H con convolucion lineal: 0.65751
Diferencia entre convolucion circular y lineal: 0.65751
</pre><p>Se observa c&oacute;mo la diferencia en el caso de la convolucion circular con la Yteorica es despreciable (orden <img src="main_eq18355575776870042606.png" alt="$10^{-15}$" style="width:32px;height:13px;">), mientras que en el caso de la convolucion lineal es ligeramente mayor a la unidad.</p><pre class="codeinput"><span class="comment">%Representacion en frecuencia para la comparaci&oacute;n Yteorica, Ylineal e</span>
<span class="comment">%Ycircular.</span>
figure
plot (f/1000,20*log(abs(Yteorica)), <span class="string">'-og'</span>);
hold <span class="string">on</span>
plot (f/1000,20*log(abs(Yc)),<span class="string">'-b'</span>);
hold <span class="string">on</span>
plot (f/1000,20*log(abs(Y)),<span class="string">'-r'</span>);
title(<span class="string">'Comparativa entre Ys'</span>);
xlabel(<span class="string">'F(Khz)'</span>);
ylabel(<span class="string">'Amplitud(db)'</span>);
legend(<span class="string">'Y teorica'</span>, <span class="string">'Ycircular'</span>, <span class="string">'Ylineal'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_07.png" alt=""> <p>Como se puede observar, la Y te&oacute;rica es id&eacute;ntica a la Y obtenida por convoluci&oacute;n</p><pre class="codeinput"><span class="comment">%circular (se ha representado la te&oacute;rica con c&iacute;rculos verdes ya que al</span>
<span class="comment">% ser id&eacute;nticas quedaba tabada completamente), mientras que la Y obtenida</span>
<span class="comment">% por convoluci&oacute;n lineal presenta diferencias en los m&iacute;nimos, los cuales llegan a valores</span>
<span class="comment">% significativamente m&aacute;s bajos que los reales.</span>
</pre><h2 id="14">2.1.6 Generaci&oacute;n del prefijo c&iacute;clico</h2><p>Se extiende x para a&ntilde;adir un prefijo c&iacute;clico al comienzo de la se&ntilde;al. Este prefijo corresponde a una repetici&oacute;n de las &uacute;ltimas muestras de x. Su longitud debe ser mayor a la longitud de la respuesta al impulso del canal, en este caso length(h) = 9 muestras. Su valor &oacute;ptimo ser&aacute; el m&iacute;nimo que cumpla esta condici&oacute;n, para as&iacute; utilizar la m&aacute;xima velocidad de transmisi&oacute;n posible, por lo que para este caso corresponde a 9 muestras. Sin embargo, por motivos de claridad en la representaci&oacute;n gr&aacute;fica, para esta pr&aacute;ctica se ha elegido un valor de 20 muestras.</p><pre class="codeinput">L=20; <span class="comment">% Longitud del prefijo c&iacute;clico</span>
<span class="comment">% Prefijo con ultimos L elementos x</span>
pref= x(length(x)-L+1:length(x));
<span class="comment">% Xextendida, a&ntilde;adiendo el prefijo al inicio. longitud=256+20=276.</span>
xext= [pref x];

<span class="comment">% Representacion en el dominio del tiempo y comparaci&oacute;n x's</span>
figure
subplot(3, 1, 1)
t = 0:Ts:(length(xext)-1)*(Ts);
plot(t, [zeros(1, L) x])
title(<span class="string">'x[n]'</span>)
grid <span class="string">on</span>
subplot(3, 1, 2)
plot(t, [pref, zeros(1, length(x))])
title(<span class="string">'Prefijo c&iacute;clico[n]'</span>)
grid <span class="string">on</span>
subplot(3, 1, 3)
plot(t, xext)
title(<span class="string">'xext[n]'</span>)
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_08.png" alt=""> <p>Como se puede observar, en el dominio temporal xext= x + prefijo. Para representar x y comparar, se a&ntilde;ade zero-padding de tama&ntilde;o L (longitud prefijo).</p><h2 id="16">2.1.7 Obtenci&oacute;n de Yc mediante convoluci&oacute;n lineal</h2><p>Realizamos la convoluci&oacute;n lineal entre xext y h para obtener yext. Para obtener yc quitamos las primeras muestras (longitud de la extensi&oacute;n c&iacute;clica) y nos quedamos con las N siguientes. Al calular el error total entre yc calculada en el apartado anterior e yc calculada en este apartado (yc1) obtenemos un valor del orden de <img src="main_eq03360613297868248192.png" alt="$10^{-14}$" style="width:18px;height:8px;">, por lo que se puede afirmar que son iguales.</p><pre class="codeinput">yext=conv(xext,h);
<span class="comment">% Quitamos las primeras muestras (longitud de la extensi&oacute;n c&iacute;clica) y nos</span>
<span class="comment">% quedamos con las N siguientes.  Longitud resultante=256.</span>
yc1=yext(length(pref)+1:length(pref)+N);
disp([<span class="string">'Diferencia yc1 (convolucion lineal con prefijo) e yc (convolucion circular): '</span> num2str(sum(abs(yc1-yc)))]);
</pre><pre class="codeoutput">Diferencia yc1 (convolucion lineal con prefijo) e yc (convolucion circular): 7.9686e-14
</pre><p>La diferencia entre la se&ntilde;al resultante de la convolucion lineal sin el prefijo y la se&ntilde;al tras la convolucion circular es insignificante, del orden de <img src="main_eq03360613297868248192.png" alt="$10^{-14}$" style="width:18px;height:8px;">. Por lo tanto, se puede concluir que son iguales, por lo que a&ntilde;adiendo un prefijo ciclico a la se&ntilde;al de entrada, la salida de la convolucion lineal(tras eliminar el prefijo)=convolucion circular.</p><p>A continuaci&oacute;n se ha representado de forma gr&aacute;fica el m&eacute;todo de obtenci&oacute;n de yc. Como se puede observar, se han descartado las L primeras muestras del vector y se ha tomado las N muestras siguientes.</p><pre class="codeinput"><span class="comment">% Representacion de forma gr&aacute;fica</span>
t = 0:Ts:(length(yext)-1)*(Ts);
figure
subplot(2, 1, 1)
plot(t, yext)
title(<span class="string">'Yextendida convolucion con prefijo L=20'</span>);
grid <span class="string">on</span>
xlabel(<span class="string">'t(s)'</span>);
ylabel(<span class="string">'yext(s)'</span>);
subplot(2,1,2)
<span class="comment">%a&ntilde;adir zero-padding para representarlo con el mismo tama&ntilde;o</span>
y1=[zeros(1,length(pref)) yc1 zeros(1, length(yext)-(length(yc1)+length(pref)))];
plot(t, y1);
title(<span class="string">'Y1 (sin prefjo)'</span>);
xlabel(<span class="string">'t(s)'</span>);
ylabel(<span class="string">'y1(s)'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_09.png" alt=""> <p>Como se puede observar en ambas gr&aacute;ficas, se ha pasado de la primera se&ntilde;al a la segunda, recortando un n&uacute;mero de muestras al inicio igual al prefijo c&iacute;clico. En la representacion se ve c&oacute;mo se ha a&ntilde;adido zero- padding al principio y al final del vector para conseguir el mismo tama&ntilde;o que yext (284) y poder representarlo, aunque en realidad este vector no lleva padding. En el rango sin padding se puede ver como las amplitudes de ambas se&ntilde;ales coinciden.</p><h2 id="20">Ejercicio 2.2 - Ecualizacion</h2><h2 id="21">2.2.1 Generaci&oacute;n de una se&ntilde;al ofdm</h2><p>Generaci&oacute;n de una se&ntilde;al ofdm con 10 subportadoras moduladas en QPSK y 100 s&iacute;mbolos ofdm. Se a&ntilde;ade un prefijo c&iacute;clico de longitud 16 pero en lugar de utilzar las &uacute;ltimas muestras de x[n], se rellena con ceros para observar el efecto que tiene a la hora de recuperar la se&ntilde;al original.</p><pre class="codeinput">NFFT  =	256;  <span class="comment">% Tama&ntilde;o de la FFT</span>
df    =  200;  <span class="comment">% Separaci&oacute;n entre portadoras</span>
Fs    =	NFFT*df;  <span class="comment">% Frecuencia de muestreo</span>
Nf    =	10;  <span class="comment">% Numero de portadoras con datos</span>
m_ary =	4;  <span class="comment">% Indicador de modulacion digital de cada portadora</span>
Nofdm  =  100;  <span class="comment">% N&uacute;mero de s&iacute;mbolos OFDM</span>
l_cp_a=16; <span class="comment">% longitud del prefijo c&iacute;clico A</span>

<span class="comment">%random bits a transmitir</span>
txbits = round(rand([1,log2(m_ary)*Nofdm*Nf]));

mod = moduladorQPSK(txbits); <span class="comment">% Generaci&oacute;n de los s&iacute;mbolos QPSK</span>
mod = reshape(mod, [Nf, Nofdm]); <span class="comment">% reordenaci&oacute;n de los s&iacute;mbolos en una matriz de Nf x Nofdm</span>

<span class="comment">%  Modulaci&oacute;n OFDM</span>
<span class="comment">%  Creaci&oacute;n de la matriz X, de componentes espectrales, para la IFFT</span>
<span class="comment">%  Incializaci&oacute;n a cero</span>
X = zeros(NFFT, Nofdm);

<span class="comment">%  Asignaci&oacute;n de los s&iacute;mbolos moduladores al espectro positivo</span>
X(29:38,:) = mod;

<span class="comment">%  Asignaci&oacute;n de los s&iacute;mbolos moduladores en orden inverso y conjugados al espectro negativo. Describa lo que realiza la funci&oacute;n flipud.</span>
X(NFFT/2+2:NFFT,:) = flipud(conj(X(2:NFFT/2,:)));

<span class="comment">% Las funcion ifft de Matlab no multiplica por el n&uacute;mero de muestras como se deber&iacute;a hacer de forma te&oacute;rica, por</span>
<span class="comment">% lo que se a&ntilde;ade manualmente.</span>
x = ifft(X, NFFT, <span class="string">'symmetric'</span>)*NFFT;

cp_a=zeros(l_cp_a,Nofdm); <span class="comment">% Prefijo ciclico de longitud 16 compuesto por ceros</span>
s = [cp_a ; x]; <span class="comment">% A&ntilde;adir prefijo ciclico</span>
s = reshape(s,  [], 1); <span class="comment">% Convertir a vector columna para su transmisi&oacute;n</span>
</pre><p>El a&ntilde;adir un prefijo c&iacute;clico formado por ceros causa que en lugar de realizar una convoluci&oacute;n circular, se realice una convoluci&oacute;n lineal. Como se ha visto antes, X&middot;H &#8800; Y, (no se cumple con la operacion FFT) por lo que habr&aacute; errores en recepci&oacute;n. Por tanto, no se podr&aacute; recuperar la se&ntilde;al original mediante ecualizaci&oacute;n, deshaciendo el efecto del canal (X&#8800;Y/H).</p><h2 id="23">2.2.2 Recepci&oacute;n de la se&ntilde;al transmitida tras pasar por el canal</h2><pre class="codeinput"> s_rx = conv(s, h);
 <span class="comment">%truncado a length(s);</span>
 s_rx = s_rx(1:end-length(h)+1);
</pre><h2 id="24">2.2.3 Eliminaci&oacute;n del periodo de guarda</h2><p>Para ello se reagrupa la se&ntilde;al recibida</p><pre class="codeinput"><span class="comment">%de forma matricial y de eliminan las primeras filas, en particular de la</span>
<span class="comment">%primera a la longitud del periodo de guarda.</span>

x_cp_rx_a = reshape(s_rx, NFFT+l_cp_a, Nofdm);
<span class="comment">% Eliminamos el prefijo c&iacute;clico</span>
x_rx_a = x_cp_rx_a(l_cp_a+(1:NFFT),:);
</pre><h2 id="25">2.2.4 Ecualizaci&oacute;n</h2><p>Ecualizacion mediante la divisi&oacute;n del espectro de la se&ntilde;al recibida entre la</p><pre class="codeinput"><span class="comment">%respuesta en frecuencia del canal. Ya que se utiliza un periodo de guarda,</span>
<span class="comment">%si este es el adecuado (longitud prefijo ciclico &gt; longitud del canal, y ultimos elementos de la se&ntilde;al de entrada), se cumple que X=Y/H.</span>

X_RX_A=fft(x_rx_a,NFFT)/NFFT;
X_RX_EQ_A =( X_RX_A ./ repmat(H.',1,Nofdm))/NFFT;  <span class="comment">%dominio frecuencia = Y/H</span>
</pre><p>A continuaci&oacute;n se compara la se&ntilde;al transmitida con la se&ntilde;al recibida. Como es de esperar, puesto que se ha utilizado un prefijo c&iacute;clico compuesto por ceros, el error no es nulo. Adem&aacute;s, es significativamente m&aacute;s grande el error en fase que en  cuadratura (eje horizontal). Se demuestra as&iacute;, que a&ntilde;adiendo un prefijo con todo 0's, no se puede recuperar la se&ntilde;al de entrada, ya que, como se demostr&oacute; en el ejercicio 1, X&middot;H &#8800; Y.</p><pre class="codeinput">disp([<span class="string">"Diferencia en recepci&oacute;n caso a: "</span> sum(sum(X_RX_EQ_A - X))])
disp([<span class="string">"Diferencia en valor absoluto en recepci&oacute;n caso a: "</span> abs(sum(sum(X_RX_EQ_A - X)))])
</pre><pre class="codeoutput">    "Diferencia en recepci&oacute;n caso a: "    "11.8787-7.34813e-16i"

    "Diferencia en valor absoluto en&#8230;"    "11.8787"

</pre><h2 id="27">2.2.5 Comparaci&oacute;n de s&iacute;mbolos QPSK</h2><p>Comparaci&oacute;n de los s&iacute;mbolos QPSK a la salida del modulador con los recibidos a la</p><pre class="codeinput"><span class="comment">%salida del ecualizador. Para ello primero es necesario recuperar deshacer</span>
<span class="comment">%la estructura de OFDM para extraer las subportadoras que contienen</span>
<span class="comment">%informaci&oacute;n. A continuaci&oacute;n, estas subportadoras se reestructuran en un</span>
<span class="comment">%vector fila y se compara con el vector de s&iacute;mbolos QPSK del transmisor.</span>

<span class="comment">% Recuperar QPSK</span>
eq_a=  X_RX_EQ_A(29:38,:);
mod=reshape(mod, 1 ,[]);
eq_a=reshape(eq_a, 1 ,[]);
<span class="comment">% Scatterplot</span>
scatterplot(mod);
title(<span class="string">'QPSK TX'</span>);
grid <span class="string">on</span>
scatterplot(eq_a);
title(<span class="string">'QPSK RX A'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="main_10.png" alt=""> <img vspace="5" hspace="5" src="main_11.png" alt=""> <p>Como se puede observar en la gr&aacute;fica, la correspondencia entre los s&iacute;mbolos no es perfecta a pesar de que no exist&iacute;a ruido en el canal. Como se ha explicado antes, esto se debe a que X&middot;H &#8800; Y. Al estar utilizando una convoluci&oacute;n lineal en lugar de la circular. En particular, se generan en vez de puntos de la constelaci&oacute;n, unos c&iacute;rculos de radio 0.1.</p><h2 id="29">2.2.6  Repetici&oacute;n con l_cp = 4</h2><p>Repetici&oacute;n de los pasos 1 a 5 esta vez con un prefijo c&iacute;clico de</p><pre class="codeinput"><span class="comment">%longitud 4, inferior a la longitud de la respuesta al impulso del canal,</span>
<span class="comment">%lo que causar&aacute; que no se pueda recuperar la se&ntilde;al transmitida tras</span>
<span class="comment">%ecualizar ya que la longitud no es suficiente como para anular la</span>
<span class="comment">%distorsi&oacute;n multicamino que se genera. Este prefijo c&iacute;clico se genera</span>
<span class="comment">%tomando las l_cp &uacute;ltimas filas de la matriz x y a&ntilde;adi&eacute;ndolas al principio</span>
<span class="comment">%de esta.</span>

l_cp_b=4;
cp_b = x(length(x)-l_cp_b+1:length(x), :);

<span class="comment">% Repetici&oacute;n de los pasos 1 a 5 para cp_b</span>
s = [cp_b ; x]; <span class="comment">% 1. A&ntilde;adir el prefijo c&iacute;clico</span>
s = reshape(s,  [], 1);
s_rx = conv(s, h); <span class="comment">% 2. Simular el canal</span>
s_rx = s_rx(1:end-length(h)+1);
x_cp_rx_b= reshape(s_rx, NFFT+l_cp_b, Nofdm);
x_rx_b = x_cp_rx_b(l_cp_b+(1:NFFT),:); <span class="comment">% 3. Eliminar el periodo de guarda</span>
X_RX_B=fft(x_rx_b,NFFT)/NFFT; <span class="comment">% 4. Ecualizar</span>
X_RX_EQ_B =( X_RX_B ./ repmat(H.',1,Nofdm))/NFFT;
</pre><p>En este caso, el error es significativamente mayor que en el apartado anterior, ya que la longitud del prefijo c&iacute;clico es menor que la longitud del canal. La se&ntilde;al resultante tras eliminar el periodo de guarda y ecualizar ya no es la se&ntilde;al original.</p><pre class="codeinput">disp([<span class="string">"Diferencia  en recepci&oacute;n caso b: "</span> sum(sum(X_RX_EQ_B - X))])
disp([<span class="string">"Diferencia en valor absoluto en recepci&oacute;n caso b: "</span> abs(sum(sum(X_RX_EQ_B - X)))])


eq_b=  X_RX_EQ_B(29:38,:);
mod=reshape(mod, 1 ,[]);
eq_b=reshape(eq_b, 1 ,[]);
scatterplot(eq_b);
title(<span class="string">'QPSK RX B'</span>);
grid <span class="string">on</span>
</pre><pre class="codeoutput">    "Diferencia  en recepci&oacute;n caso b: "    "30.2677-3.32438e-15i"

    "Diferencia en valor absoluto en&#8230;"    "30.2677"

</pre><img vspace="5" hspace="5" src="main_12.png" alt=""> <p>En este caso, en vez de generar c&iacute;rculos en torno a los valores de la constelaci&oacute;n, se generan una especie de arco de circunferencia en torno a estos. Esto se debe a haber utilizado un prefijo c&iacute;clico de longitud menor a la respuesta al impulso del canal. El radio sigue siendo de aproximadamente 0.1 aunque, como se ha dicho, solo se encuentra en la zona m&aacute;s pr&oacute;xima a la horizontal, es decir, el error en fase es significativamente m&aacute;s alto que en cuadratura.</p><h2 id="32">2.2.7 Repetici&oacute;n con l_cp = 16</h2><p>Repetici&ntilde;on de los pasos 1 a 5 esta vez con un prefijo c&iacute;clico de</p><pre class="codeinput"><span class="comment">%longitud 16, superior a la longitud de la respuesta al impulso del canal,</span>
<span class="comment">%lo que causar&aacute; que no s&iacute; pueda recuperar la se&ntilde;al transmitida tras</span>
<span class="comment">%ecualizar ya que la longitud es suficiente para anular la</span>
<span class="comment">%distorsi&oacute;n multicamino que se genera. Este prefijo c&iacute;clico se genera</span>
<span class="comment">%tomando las 16 &uacute;ltimas filas de la matriz x y a&ntilde;adi&eacute;ndolas al principio</span>
<span class="comment">%de esta.</span>

l_cp_c=16;
cp_c = x(length(x)-l_cp_c+1:length(x), :);
</pre><p>Repetici&oacute;n de los pasos 1 a 5 para cp_c</p><pre class="codeinput">s = [cp_c ; x]; <span class="comment">% 1. A&ntilde;adir el prefijo c&iacute;clico</span>
s = reshape(s,  [], 1);
s_rx = conv(s, h); <span class="comment">% 2. Simular el canal</span>
s_rx = s_rx(1:end-length(h)+1);
x_cp_rx_c= reshape(s_rx, NFFT+l_cp_c, Nofdm);
x_rx_c = x_cp_rx_c(l_cp_c+(1:NFFT),:); <span class="comment">% 3. Eliminar el periodo de guarda</span>
X_RX_C=fft(x_rx_c,NFFT)/NFFT; <span class="comment">% 4. Ecualizar</span>
X_RX_EQ_C =( X_RX_C ./ repmat(H.',1,Nofdm))/NFFT;
</pre><p>En este caso, ya que la longitud del prefijo es &gt; que la longitud del canal, y se a&ntilde;aden los ultimos l_cp_c elementos de la se&ntilde;al de entrada, tras la convolucion lineal, eliminar el periodo de guarda y ecualizar, la diferencia en recepcci&oacute;n es del orden de <img src="main_eq03360613297868248192.png" alt="$10^{-14}$" style="width:18px;height:8px;"> (m&oacute;dulo), por lo que podemos concluir que las se&ntilde;ales son iguales. Gracias al prefijo, podemos recuperar mediante la ecualizaci&oacute;n (deshaciendo el efecto del canal con su inversa) la se&ntilde;al de transmisi&oacute;n en OFDM.</p><pre class="codeinput">disp([<span class="string">"Diferencia en recepci&oacute;n caso c: "</span> sum(sum(X_RX_EQ_C - X))]);
disp([<span class="string">"Diferencia en valor absoluto en recepci&oacute;n caso c: "</span> abs(sum(sum(X_RX_EQ_C - X)))]);

eq_c=  X_RX_EQ_C(29:38,:);
mod=reshape(mod, 1 ,[]);
eq_c=reshape(eq_c, 1 ,[]);
scatterplot(eq_c);
title(<span class="string">'QPSK RX C'</span>);
grid <span class="string">on</span>
</pre><pre class="codeoutput">    "Diferencia en recepci&oacute;n caso c: "    "-1.4938e-14-8.6836e-30i"

    "Diferencia en valor absoluto en&#8230;"    "1.4938e-14"

</pre><img vspace="5" hspace="5" src="main_13.png" alt=""> <p>Esta vez la constelaci&oacute;n obtenida es perfecta. Se demuestra as&iacute; que en ausencia de ruido, utilizando un prefijo c&iacute;clico de longitud superior a la respuesta al impulso del canal, es posible recuperar a la prefecci&oacute;n la se&ntilde;al orginal, eliminando la distorsi&oacute;n multitrayecto del canal en OFDM. Como es l&oacute;gico, esto solo es posible si se cuenta con el comportamiento exacto de H. En la pr&aacute;ctica tan solo se cuenta con una estimaci&oacute;n, por lo que existir&aacute; error en recepci&oacute;n. Adem&aacute;s, la respuesta al impulso no suele ser constante en el tiempo, por lo que no solo ser&aacute; necesario estimarla, sino que adem&aacute;s se deber&aacute; actualizar peri&oacute;dicamente si se quiere asegurar su validez.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####

%% Práctica 5 - Prefijo cíclico
% Teresa González García y María José Medina Hernández

%% Ejercicio 2.1 - Convolucion circular

%% 2.1.1 Representación del espectro de x en dB

% N puntos FFT
N=256;
% frecuencia de muestreo
Fs=25600;
% periodo de muestreo
Ts=1/Fs;

% señal de entrada aleatoria
x=randi([-1,1],1,N);

% X(f) -> FFT. Es necesario escalar las amplitudes /N para que la operación fft de
% matlab coincida con la fórmula teórica.
X=fft(x,N)/N;

% vector f (paso Fs) -> mitad puntos NFFT espectro + y mitad -
f=-N*Fs/2:Fs:N*Fs/2-Fs;

%Se representa el espectro del canal en dbs con fftshift, para visualizar el resultado de la FFT con el componente de f=0 en el centro del espectro.
figure
plot (f/1000,20*log(abs(fftshift(X))));
title('Representacion abs(X(f)) en db');
xlabel('F(Khz)');
ylabel('Amplitud(db)');
grid on

%%
% Se representa el espectro de una señal aleatoria (valores -1, 0,1) de N
% puntos. Como se puede observar, el espectro es simétrico, ya que las
% amplitudes (en valor absoluto) de las frecuencias de rango -N/2*Fs a 0
% coiciden con las de las frecuencias de rango 0 a +N/2*Fs. 

%% 2.1.2 Representación de H en dB

% h[n] es un filtro digital de k=9 posiciones en total (en el dominio del tiempo
% discreto).
h=[-0.1,0.3,-0.5,0.7,-0.9,0.7, -0.5, 0.3, -0.1];

% H(f) es la respuesta al impulso del canal -> FFT.
H=fft(h,N)/N;
% Representacion |H(f)| el dominio de la frecuencia (db)
figure
plot (f/1000,20*log(abs(fftshift(H))));
title('Representacion |H(f)| en db');
xlabel('F(Khz)');
ylabel('|Amplitud(db)|');
grid on

%Representacion |H(f)| en el dominio de la frecuencia (unidades naturales)
figure
plot(f/1000,abs(fftshift(H)));
title('Representacion |H(f)|');
xlabel('F(Khz)');
ylabel('Amplitud');
grid on

%Representacion |H(f)| en el dominio de la frecuencia (unidades naturales)
figure
plot(f/1000,abs(fftshift(H)));
title('Representacion |H(f)|');
xlabel('F(Khz)');
ylabel('Amplitud');
grid on

%%
% 
% Como se puede observar, el espectro de nuevo es simétrico, y corresponde
% a un filtro que atenúa la señal de entrada principalmente en el rango de
% frecuencias de -2000Khz a 2000Khz. Deja pasar los tonos en f=-3000Khz y
% 3000Khz.

%% 2.1.3 Cálculo de la convolución lineal y representación del espectro de Y en dB
% y es la señal en recibida, es decir, x convolucionada con la respuesta al
% impulso del canal (h). El canal provocará un retardo y un escalado de
% amplitud (atenuación) de la señal de entrada x -> y=suma(ak*x[n-k]).
% convolucion lineal
y=conv(x,h);
% y(f) = NFFT.
Y=fft(y,N)/N;
figure;
plot (f/1000,20*log(abs(fftshift(Y))));
title('Representacion Y(f) en db');
xlabel('F(Khz)');
ylabel('Amplitud(db)');
grid on

%%
%  En la gráfica se puede observar como las amplitudes de Y(f) resultante
%  se encuentran muy atenuadas en comparación con las amplitudes de X(f)
%  (f=0, X(0)=-93db, Y(0)=-143 db,  debido al efecto del canal). También se
%  observa como las amplitudes en f=+-3000Khz son las menos atenuadas
%  (-20db aprox). Se tiene en cuenta que la y[n] se encuentra retardada en
%  el tiempo, por lo que está adelantada en frecuencia.


%% 2.1.4 Cálculo de la convolución circular y representación del espectro de Yc en dB
% Para calcular la convolucion circular de x*h, se ha utilizado la función
% cconv de MATLAB módulo N. Por defecto la función cconv devuleve un vector
% de longitud LENGTH(A)+LENGTH(B)-1, lo cual es equivalente a la
% convolución lineal. Sin embargo, nosotros necesitamos que sea de longitud
% N porque quremos que tenga la misma longitud que x = 256.
yc=cconv(x,h,N);
Yc=fft(yc,N)/N;
figure;
plot (f/1000,20*log(abs(fftshift(Yc))));
title('Representacion Yc(f) en db');
xlabel('F(Khz)');
ylabel('Amplitud(db)');
grid on

%% 
% Se observan las mismas conclusiones en cuanto a atenuación que en el
% apartado anterior, pero el espectro es distinto en el rango de
% frecuencias +-2000Khz, porque las amplitudes resultantes de la
% convolución circular son distintos a los de la convolución lineal.
%% 2.1.5 Comparación de Y teórica, Y e Yc
% A continuación se comparan la Y teórica (X.*H*N) con la Y obtenida por
%convolución circular y la obtenida por convolución lineal.
% Se escala X*H (*N), ya que X*H resulta en amplitudes /N^2. Así, se puede
% comparar con las Y's (escaladas /N).
Yteorica= (X.*H*N);
dif_circular=sum(abs(Yc - Yteorica));
disp(['Diferencia X*H con convolucion circular: ' num2str(dif_circular)]);
dif_lineal=sum(abs(Y-Yteorica));
disp(['Diferencia X*H con convolucion lineal: ' num2str(dif_lineal)]);
disp(['Diferencia entre convolucion circular y lineal: ' num2str(abs(dif_circular-dif_lineal))]);
%%
% Se observa cómo la diferencia en el caso de la convolucion circular con
% la Yteorica es despreciable (orden $10^{-15}$), mientras que en el caso de la
% convolucion lineal es ligeramente mayor a la unidad. 

%Representacion en frecuencia para la comparación Yteorica, Ylineal e
%Ycircular.
figure
plot (f/1000,20*log(abs(Yteorica)), '-og');
hold on 
plot (f/1000,20*log(abs(Yc)),'-b');
hold on 
plot (f/1000,20*log(abs(Y)),'-r');
title('Comparativa entre Ys');
xlabel('F(Khz)');
ylabel('Amplitud(db)');
legend('Y teorica', 'Ycircular', 'Ylineal');
grid on


%%
% Como se puede observar, la Y teórica es idéntica a la Y obtenida por convolución
%circular (se ha representado la teórica con círculos verdes ya que al 
% ser idénticas quedaba tabada completamente), mientras que la Y obtenida 
% por convolución lineal presenta diferencias en los mínimos, los cuales llegan a valores
% significativamente más bajos que los reales.

%% 2.1.6 Generación del prefijo cíclico
% Se extiende x para añadir un prefijo cíclico al comienzo de la señal. 
% Este prefijo corresponde a una repetición de las últimas muestras de x.
% Su longitud debe ser mayor a la longitud de la respuesta al impulso del
% canal, en este caso length(h) = 9 muestras. Su valor óptimo será el mínimo que cumpla 
% esta condición, para así utilizar la máxima velocidad de transmisión
% posible, por lo que para este caso corresponde a 9 muestras. Sin embargo,
% por motivos de claridad en la representación gráfica, para esta práctica
% se ha elegido un valor de 20 muestras.

L=20; % Longitud del prefijo cíclico
% Prefijo con ultimos L elementos x
pref= x(length(x)-L+1:length(x));
% Xextendida, añadiendo el prefijo al inicio. longitud=256+20=276.
xext= [pref x];

% Representacion en el dominio del tiempo y comparación x's
figure
subplot(3, 1, 1)
t = 0:Ts:(length(xext)-1)*(Ts);
plot(t, [zeros(1, L) x])
title('x[n]')
grid on
subplot(3, 1, 2)
plot(t, [pref, zeros(1, length(x))])
title('Prefijo cíclico[n]')
grid on
subplot(3, 1, 3)
plot(t, xext)
title('xext[n]')
grid on
%% 
% Como se puede observar, en el dominio temporal xext= x + prefijo. Para
% representar x y comparar, se añade zero-padding de tamaño L (longitud prefijo).
%% 2.1.7 Obtención de Yc mediante convolución lineal
% Realizamos la convolución lineal entre xext y h para obtener yext. Para
% obtener yc quitamos las primeras muestras (longitud de la extensión cíclica) y nos
% quedamos con las N siguientes. Al calular el error total entre yc
% calculada en el apartado anterior e yc calculada en este apartado (yc1)
% obtenemos un valor del orden de $10^{-14}$, por lo que se puede afirmar
% que son iguales.

yext=conv(xext,h);
% Quitamos las primeras muestras (longitud de la extensión cíclica) y nos
% quedamos con las N siguientes.  Longitud resultante=256.
yc1=yext(length(pref)+1:length(pref)+N);
disp(['Diferencia yc1 (convolucion lineal con prefijo) e yc (convolucion circular): ' num2str(sum(abs(yc1-yc)))]);
%%
% La diferencia entre la señal resultante de la convolucion lineal sin el
% prefijo y la señal tras la convolucion circular es insignificante, del
% orden de $10^{-14}$. Por lo tanto, se puede concluir que son iguales, por
% lo que añadiendo un prefijo ciclico a la señal de entrada, la salida de la convolucion
% lineal(tras eliminar el prefijo)=convolucion circular.
%% 
% A continuación se ha representado de forma gráfica el método de obtención
% de yc.
% Como se puede observar, se han descartado las L primeras muestras del
% vector y se ha tomado las N muestras siguientes. 

% Representacion de forma gráfica
t = 0:Ts:(length(yext)-1)*(Ts);
figure
subplot(2, 1, 1)
plot(t, yext)
title('Yextendida convolucion con prefijo L=20');
grid on
xlabel('t(s)');
ylabel('yext(s)');
subplot(2,1,2)
%añadir zero-padding para representarlo con el mismo tamaño
y1=[zeros(1,length(pref)) yc1 zeros(1, length(yext)-(length(yc1)+length(pref)))];
plot(t, y1);
title('Y1 (sin prefjo)');
xlabel('t(s)');
ylabel('y1(s)');
grid on

%% 
% Como se puede observar en ambas gráficas, se ha pasado de la primera
% señal a la segunda, recortando un número de muestras al inicio igual al
% prefijo cíclico.
% En la representacion se ve cómo se ha añadido zero- padding al principio
% y al final del vector para conseguir el mismo tamaño que yext (284) y
% poder representarlo, aunque en realidad este vector no lleva padding. En
% el rango sin padding se puede ver como las amplitudes de ambas señales
% coinciden.

%% Ejercicio 2.2 - Ecualizacion

%% 2.2.1 Generación de una señal ofdm
% Generación de una señal ofdm con 10 subportadoras moduladas en QPSK y
% 100 símbolos ofdm. Se añade un prefijo cíclico de longitud 16 pero en
% lugar de utilzar las últimas muestras de x[n], se rellena con ceros para
% observar el efecto que tiene a la hora de recuperar la señal original.

NFFT  =	256;  % Tamaño de la FFT
df    =  200;  % Separación entre portadoras
Fs    =	NFFT*df;  % Frecuencia de muestreo
Nf    =	10;  % Numero de portadoras con datos
m_ary =	4;  % Indicador de modulacion digital de cada portadora
Nofdm  =  100;  % Número de símbolos OFDM
l_cp_a=16; % longitud del prefijo cíclico A

%random bits a transmitir
txbits = round(rand([1,log2(m_ary)*Nofdm*Nf]));

mod = moduladorQPSK(txbits); % Generación de los símbolos QPSK
mod = reshape(mod, [Nf, Nofdm]); % reordenación de los símbolos en una matriz de Nf x Nofdm
 
%  Modulación OFDM
%  Creación de la matriz X, de componentes espectrales, para la IFFT
%  Incialización a cero 
X = zeros(NFFT, Nofdm);

%  Asignación de los símbolos moduladores al espectro positivo
X(29:38,:) = mod;

%  Asignación de los símbolos moduladores en orden inverso y conjugados al espectro negativo. Describa lo que realiza la función flipud.
X(NFFT/2+2:NFFT,:) = flipud(conj(X(2:NFFT/2,:)));

% Las funcion ifft de Matlab no multiplica por el número de muestras como se debería hacer de forma teórica, por
% lo que se añade manualmente.
x = ifft(X, NFFT, 'symmetric')*NFFT;

cp_a=zeros(l_cp_a,Nofdm); % Prefijo ciclico de longitud 16 compuesto por ceros
s = [cp_a ; x]; % Añadir prefijo ciclico
s = reshape(s,  [], 1); % Convertir a vector columna para su transmisión

%%
% El añadir un prefijo cíclico formado por ceros causa que en lugar de
% realizar una convolución circular, se realice una convolución lineal.
% Como se ha visto antes, X·H ≠ Y, (no se cumple con la operacion FFT) por lo que habrá errores en recepción.
% Por tanto, no se podrá recuperar la señal original mediante ecualización,
% deshaciendo el efecto del canal (X≠Y/H).


%% 2.2.2 Recepción de la señal transmitida tras pasar por el canal 
 s_rx = conv(s, h);
 %truncado a length(s);
 s_rx = s_rx(1:end-length(h)+1);
 
%% 2.2.3 Eliminación del periodo de guarda
% Para ello se reagrupa la señal recibida
%de forma matricial y de eliminan las primeras filas, en particular de la
%primera a la longitud del periodo de guarda. 

x_cp_rx_a = reshape(s_rx, NFFT+l_cp_a, Nofdm);
% Eliminamos el prefijo cíclico
x_rx_a = x_cp_rx_a(l_cp_a+(1:NFFT),:);

%% 2.2.4 Ecualización
% Ecualizacion mediante la división del espectro de la señal recibida entre la
%respuesta en frecuencia del canal. Ya que se utiliza un periodo de guarda,
%si este es el adecuado (longitud prefijo ciclico > longitud del canal, y ultimos elementos de la señal de entrada), se cumple que X=Y/H.

X_RX_A=fft(x_rx_a,NFFT)/NFFT;
X_RX_EQ_A =( X_RX_A ./ repmat(H.',1,Nofdm))/NFFT;  %dominio frecuencia = Y/H
%%
% A continuación se compara la señal transmitida con la señal recibida.
% Como es de esperar, puesto que se ha utilizado un prefijo cíclico
% compuesto por ceros, el error no es nulo. Además, es significativamente más grande el error en fase que en
%  cuadratura (eje horizontal).
% Se demuestra así, que añadiendo un prefijo con todo 0's, no se puede
% recuperar la señal de entrada, ya que, como se demostró en el ejercicio 1, X·H ≠ Y.
disp(["Diferencia en recepción caso a: " sum(sum(X_RX_EQ_A - X))])
disp(["Diferencia en valor absoluto en recepción caso a: " abs(sum(sum(X_RX_EQ_A - X)))])

%% 2.2.5 Comparación de símbolos QPSK
% Comparación de los símbolos QPSK a la salida del modulador con los recibidos a la
%salida del ecualizador. Para ello primero es necesario recuperar deshacer
%la estructura de OFDM para extraer las subportadoras que contienen
%información. A continuación, estas subportadoras se reestructuran en un
%vector fila y se compara con el vector de símbolos QPSK del transmisor.

% Recuperar QPSK
eq_a=  X_RX_EQ_A(29:38,:);
mod=reshape(mod, 1 ,[]);
eq_a=reshape(eq_a, 1 ,[]);
% Scatterplot
scatterplot(mod);
title('QPSK TX');
grid on
scatterplot(eq_a);
title('QPSK RX A');
grid on

%%
% Como se puede observar en la gráfica, la correspondencia entre los
% símbolos no es perfecta a pesar de que no existía ruido en el canal. Como
% se ha explicado antes, esto se debe a que X·H ≠ Y. Al estar utilizando
% una convolución lineal en lugar de la circular. En particular, se generan
% en vez de puntos de la constelación, unos círculos de radio 0.1.
%% 2.2.6  Repetición con l_cp = 4
% Repetición de los pasos 1 a 5 esta vez con un prefijo cíclico de
%longitud 4, inferior a la longitud de la respuesta al impulso del canal,
%lo que causará que no se pueda recuperar la señal transmitida tras
%ecualizar ya que la longitud no es suficiente como para anular la
%distorsión multicamino que se genera. Este prefijo cíclico se genera
%tomando las l_cp últimas filas de la matriz x y añadiéndolas al principio
%de esta.

l_cp_b=4;
cp_b = x(length(x)-l_cp_b+1:length(x), :);

% Repetición de los pasos 1 a 5 para cp_b
s = [cp_b ; x]; % 1. Añadir el prefijo cíclico
s = reshape(s,  [], 1);
s_rx = conv(s, h); % 2. Simular el canal
s_rx = s_rx(1:end-length(h)+1);
x_cp_rx_b= reshape(s_rx, NFFT+l_cp_b, Nofdm);
x_rx_b = x_cp_rx_b(l_cp_b+(1:NFFT),:); % 3. Eliminar el periodo de guarda
X_RX_B=fft(x_rx_b,NFFT)/NFFT; % 4. Ecualizar
X_RX_EQ_B =( X_RX_B ./ repmat(H.',1,Nofdm))/NFFT;

%%
% En este caso, el error es significativamente mayor que en el apartado
% anterior, ya que la longitud del prefijo cíclico es menor que la longitud
% del canal. La señal resultante tras eliminar el periodo de guarda y
% ecualizar ya no es la señal original.
disp(["Diferencia  en recepción caso b: " sum(sum(X_RX_EQ_B - X))])
disp(["Diferencia en valor absoluto en recepción caso b: " abs(sum(sum(X_RX_EQ_B - X)))])


eq_b=  X_RX_EQ_B(29:38,:);
mod=reshape(mod, 1 ,[]);
eq_b=reshape(eq_b, 1 ,[]);
scatterplot(eq_b);
title('QPSK RX B');
grid on

%%
% En este caso, en vez de generar círculos en torno a los valores de la
% constelación, se generan una especie de arco de circunferencia en torno a
% estos. Esto se debe a haber utilizado un prefijo cíclico de longitud menor
% a la respuesta al impulso del canal. El radio sigue siendo de
% aproximadamente 0.1 aunque, como se ha dicho, solo se encuentra en la
% zona más próxima a la horizontal, es decir, el error en fase es
% significativamente más alto que en cuadratura.

%% 2.2.7 Repetición con l_cp = 16
% Repeticiñon de los pasos 1 a 5 esta vez con un prefijo cíclico de
%longitud 16, superior a la longitud de la respuesta al impulso del canal,
%lo que causará que no sí pueda recuperar la señal transmitida tras
%ecualizar ya que la longitud es suficiente para anular la
%distorsión multicamino que se genera. Este prefijo cíclico se genera
%tomando las 16 últimas filas de la matriz x y añadiéndolas al principio
%de esta.

l_cp_c=16;
cp_c = x(length(x)-l_cp_c+1:length(x), :);
%%
% Repetición de los pasos 1 a 5 para cp_c
s = [cp_c ; x]; % 1. Añadir el prefijo cíclico
s = reshape(s,  [], 1);
s_rx = conv(s, h); % 2. Simular el canal
s_rx = s_rx(1:end-length(h)+1);
x_cp_rx_c= reshape(s_rx, NFFT+l_cp_c, Nofdm);
x_rx_c = x_cp_rx_c(l_cp_c+(1:NFFT),:); % 3. Eliminar el periodo de guarda
X_RX_C=fft(x_rx_c,NFFT)/NFFT; % 4. Ecualizar
X_RX_EQ_C =( X_RX_C ./ repmat(H.',1,Nofdm))/NFFT;
%%
% En este caso, ya que la longitud del prefijo es > que la longitud del
% canal, y se añaden los ultimos l_cp_c elementos de la señal de entrada,
% tras la convolucion lineal, eliminar el periodo de guarda y ecualizar, la
% diferencia en recepcción es del orden de $10^{-14}$ (módulo), por lo que
% podemos concluir que las señales son iguales. Gracias al prefijo, podemos
% recuperar mediante la ecualización (deshaciendo el efecto del canal con
% su inversa) la señal de transmisión en OFDM.
disp(["Diferencia en recepción caso c: " sum(sum(X_RX_EQ_C - X))]);
disp(["Diferencia en valor absoluto en recepción caso c: " abs(sum(sum(X_RX_EQ_C - X)))]);

eq_c=  X_RX_EQ_C(29:38,:);
mod=reshape(mod, 1 ,[]);
eq_c=reshape(eq_c, 1 ,[]);
scatterplot(eq_c);
title('QPSK RX C');
grid on

%%
% Esta vez la constelación obtenida es perfecta. Se demuestra así que en
% ausencia de ruido, utilizando un prefijo cíclico de longitud superior a
% la respuesta al impulso del canal, es posible recuperar a la prefección
% la señal orginal, eliminando la distorsión multitrayecto del canal en OFDM.
% Como es lógico, esto solo es posible si se cuenta con
% el comportamiento exacto de H. En la práctica tan solo se cuenta con una
% estimación, por lo que existirá error en recepción. Además, la respuesta
% al impulso no suele ser constante en el tiempo, por lo que no solo será
% necesario estimarla, sino que además se deberá actualizar periódicamente
% si se quiere asegurar su validez.





##### SOURCE END #####
--></body></html>